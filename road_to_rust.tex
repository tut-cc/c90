\chapter{Rustへの道}
\begin{quotation}
  Program testing can be a very effective way to show the presence of bugs, \\
  but is hopelessly inadequate for showing their absence. ...

  The programmer should let correctness proof and program grow hand in hand.
\end{quotation}
\begin{flushright}
  --- Edsger W. Dijkstra,``The Humble Programmer'' (1972)
\end{flushright}

\section{前書き}
この種の同人誌に於ける利点は，何と言っても全く意識外の情報を仕入れる機会が得られる所だろう．
すると弊サークルのプログラミング言語大好きおじさんこと， \verb|@_Nnwww| が貴方に寄せる本記事の内容は1つしか無い，急進にして注目のプログラミング言語紹介である．
まぁ急進にして注目のといえば人の属する界隈によりけりだが，ここでは正式リリースから1年が経過し，
2016年にstack Overflowが行ったデベロッパー向けの調査にて「最も愛されている言語」に登りつめたプログラミング言語\cite{most_loved}，
「Rust」について紹介しよう．
即ち，本記事はRustについて，その言語が現れた文脈を共有しない読者の事も頭の幾らかに残しつつ，その理念や設計について示すものである．

なお，貴方がRustに今すぐ入門する意気に溢れているならばこの記事を読むよりも
rustup\cite{rustup}を導入し，
有志による翻訳リポジトリ\cite{rustdoc_ja}(拙訳も提供させていただいた)及びRustnomicon\cite{nomicon}の読破を推奨する．

間違い等については前述のアカウントに御一報下さい．文体ですか？やってみたかっただけです :)

\section{Rustとは}
Rustは「ゼロコスト抽象化」を実現する「トレイト」ベースの静的型付き「手続き型プログラミング」言語である．完！

というのは言葉足らずの私の主観だが事実しか並んでいない筈だ．
もう少し真面目に話せば1400人以上ものコントリビュータによって開発されているLLVMバックエンドのネイティブコンパイル言語であり，
Mozillaが製作中の新作webレンダリングエンジンServoの実装に用いられている．
公式では安全性，速度．並行性の3つの目標にフォーカスし，それらをガーベジコレクタ無しで実現するシステムプログラミング言語である，といった紹介がなされており，
レイヤ的にはこれまでC/C++のような言語が取り組んでいた領域に昨今の知見を持ち込む進捗だと言えるだろう．

さて，少なくともこの言語の場合，来たる知見の方角を意識しつつ機能を咀嚼するとわかりやすい．といっても大別して2つだと考えられる．
即ち「関数型プログラミングから来た知見」と「同レイヤの先達 （主にC++）にて醸成された知見」である．それでは見ていこう．

\section{ゼロコスト抽象化}
強力な抽象化，安全性検査等を実行時のコストを払わずに実現するという思想．
力の限り不適切に形容すると「あ〜HaskellがC言語並の実行速度で動かないかなぁ」という考えであり，プログラミングの理想主義である．
まさにRustの性格そのものであり，この理念に基づいて言語機能やライブラリが設計されている．
従ってコードを書く際のつらみも，書かれたコードのつよみも，大体この思想に依るものである．

\subsection{トレイト}
C++やJava，C\# に代表されるジェネリクスについて思い出して欲しい．
型をパラメータTに置き換える事により，逐一具体的な型についてコピーアンドペーストしなくとも
汎ゆる型を扱う事の出来る凄い奴だ．
だが，これらの言語のジェネリクスの型パラメータはそれがどういった性質の型であるか制約を課す事が出来ない．
そのため「ジェネリックな関数内のどの式でエラーが起きたか」は知ることが出来るが，
「その型にどういった性質が欠如していたのか」を具体的に知ることは出来ないのである．\footnote{C++ではテンプレートメタプログラミングに依るConceptという手法で実現可能． \\ 広く使われるように言語機能として熱望されているが，C++11の頃から今日まで延期され続けている...}

するとジェネリクスについて我々は考えを改めなければならない．
我々が必要なのは「汎ゆる型」ではなく，「特定の性質を持つ汎ゆる型」なのである．

トレイトとはこの語の和訳の通り，ある型が有する「特質」乃至は「特徴」を表す言語機能である．
此処で言う特質とは特定のシグネチャの関数群や関連する型が適切に実装されている事を指す．

せつめい〜

明らかに型クラスでは？と思った一部の諸兄，残念ながらHigherKindType対応では無いためFunctor等は努力が必要である．
RustはLLVMに依る最適化を受ける言語ではあるものの，モナ度の高まりはコンパイル時，実行時共にコストが蓄積しがちな代物であるし，
ゼロコスト抽象化と記述力向上を共に実現する言語機能として
健全なマクロとnightlyなコンパイラプラグインがあるため，諦めるのが賢明だろう．
これらの機能については入門してからのお楽しみである．

\subsection{所有権システム}
ゼロコスト抽象化を担う象徴的な機能のもう1つが所有権システムである．具体的には幾つかの概念，機能をまとめてこう記述されている．

\subsubsection{所有権そしてムーブセマンティクス}

\subsubsection{借用}
直接data raceの条件を書き下したかのような制約はRust発の特徴であると思われる．先達に心当たり有る方は是非御一報を．

\subsubsection{ライフタイム}
背景にはML KitやCycloneといった言語で実装されているRegionを用いた手法があるようだが残念ながら筆者の認識は概略程度であり元論文等は未読である．
より意欲的な読者は調べてみるのが良いだろう．


\section{現代の手続き型プログラミング}
Rustはマルチパラダイムのプログラミング言語だ．従って特定のプログラミングのスタイルを強くサポートする形態をとらない．
例えばRustはオブジェクト指向プログラミング言語\footnote{ここではメッセージング指向ではなくBjarne Stroustrup氏がC++に取り込みJava等でも用いられている「ユーザ定義型としてのオブジェクト指向」に仮定する}ではない．
そもそもオブジェクトは無く，再現ができる機能は分割，分散されている．
\begin{itemize}
\item データ型単位ではなくモジュールがアクセスコントロールを行う
\item トレイトの「継承」による差分プログラミング
  \begin{itemize}
  \item この「継承」は実装しなければならないトレイトが増えるだけ(デフォルト実装等により導出は可能)
  \item OOPと異なり多態性を持たない
  \item OOPの継承による階層構造よりも結合度は低い
  \end{itemize}
\item トレイトオブジェクトによる動的ディスパッチがオブジェクトの多態性に近い
  \begin{itemize}
  \item vtableと同様の仕組みを用いている
  \end{itemize}
\end{itemize}
また，Rustは関数型プログラミング言語でもない．相性の悪いポイントは幾つも見当たる．
\begin{itemize}
\item 高階関数と相性が悪い標準のマクロtry!が有る
\item 標準ライブラリには副作用抑制より速度を取っている実装もある
  \begin{itemize}
  \item mut参照による引数を介した書き戻しなど
  \item それをラッピングし意識させないような工夫は行われている
  \end{itemize}
\item Rustは末尾再帰の最適化を保証しない
  \begin{itemize}
  \item LLVMに任せるのみ
  \end{itemize}
\end{itemize}

局所的にそういったスタイルの再現や模倣は可能であるが，常に行うのは得策とは言えないだろう．

ではRustはどのようなプログラミング言語なのだろうか？
Rustは現代の手続き型プログラミング言語だと言えるだろう．

\subsection{補足: 副作用}

\subsection{デフォルトイミュータブル}

\subsection{式指向}
多くの手続き型プログラミング言語ではif文が有名だろう．
以下はC言語での条件に応じた初期化である．

\begin{lstlisting}[language={C},caption=Cにおけるif文,label=c_if]
int cond = 5;

int res = 0;

if (cond == 5) {
    res = 10;
} else {
    res = 15;
}
\end{lstlisting}
式指向な言語，Rustでは以下のようになる．
\begin{lstlisting}[language={C++},caption=Rustにおけるif式,label=rust_if]
let cond = 5;
let res = if cond == 5 { 10 } else { 15 };
\end{lstlisting}
この些末なコードに意味はない．文にはスコープの隔たりがあり，余計な副作用の発生や，表現が途中で切断されるといった問題に注目して欲しい．

Rustではletによる変数宣言を除き単体での文は存在しない．基本的に式でプログラミングを構成していく事から公式はRustを「式指向」な言語と称している．
しかし文が使えない訳では無く，セミコロンを式に加えて返り値が無い(これは不正確である．詳細は入門してry)事を明示し，式を文にすることができる．ドキュメントでは．これを式文と表現している．
お馴染み `for` のようなループも使用可能である．これ以上は詳細に立ち入ってしまうため，どのように整合性を保たれているかは実際に入門して確かめてみて欲しい．
なお，この特徴的なセミコロンの使い方はSMLやOCamlからの影響であることが明言されている．

\subsection{より疎結合なインターフェースとしてのトレイト}


\subsection{モジュールによる構造化とアクセスコントロール}


\subsection{enum型とパターンマッチング}
代数的データ型，直和型，タグ付き共用体，他の言語では色々な呼ばれ方をしているが，Rustではそれをenumと呼んでいる．
これらは関数型プログラミングの知見が出自である．少なくともRustが影響を受けた出自はそうだ．
せつめい〜
enum型の強みはこの型を開く時，必ずバリアントの網羅性を要求することだ．
つまり，値を取り出そうとする際に，全てのバリアントの扱いを網羅できておらず，かつデフォルトのパターンも存在しない場合，コンパイルエラーとなるのである．
以上によって \textbf{nullの無い世界} が開かれる．値が無い可能性を有する型はenumに依って簡単に表現できるからだ．
\begin{lstlisting}[language={C++},caption=Option型,label=option_t]
enum Option<T> {
    None,
    Some(T),
}
\end{lstlisting}
エラーの際に情報を値として返したいならば，
\begin{lstlisting}[language={C++},caption=Result型,label=result_t]
enum Result<T, E> {
    Ok(T),
    Err(E),
}
\end{lstlisting}
が標準ライブラリで定義されている．(私個人としてはエラーに限らず「どちらかの値」を表すHaskellのEitherの方が優れた命名だと考えている)

Quick Sort，Hoare論理，CSPの作者として知られるTony Hoare氏はnullを10億ドル相当の過ちと称した．
我々はこの型の直和を持って，古い時代から脱出すべきなのだ．(といっても関数型プログラミングでは随分昔から用いられていたのだが)

\section{「例外」の無いエラーハンドリング}
さて本節ではRustのシステムプログラミングらしい側面について取り扱う．

\section{Rustの門を叩く}
rustは現在バージョン1.10.0
現在ライブラリの仕様がどんどんstableになっている最中
Rustは実践的な言語を目指しており，
安定化から1周年であるが非常に多くのドキュメントが書かれている．
従って今回は詳細な入門を書く事は避け，
如何なる要請に基づいて彼らがRustへ至ったのか，その道筋の一端を述べようと試みた．

貴方が門を叩き，理想のプログラミングを追求する一助と成れたならば幸いである．

\begin{thebibliography}{9}
\bibitem{most_loved} stackoverflow Developer Survey Results 2016 \\
  \url{https://stackoverflow.com/research/developer-survey-2016}
\bibitem{rustup} rustup: the Rust toolchain installer \\
  \url{https://github.com/rust-lang-nursery/rustup.rs}
\bibitem{rustdoc_ja} rust-lang-ja/the-rust-programming-language-ja \\
  \url{https://github.com/rust-lang-ja/the-rust-programming-language-ja}
\bibitem{nomicon} The Rustnomicon - The Dark Arts of Advanced and Unsafe Rust Programming \\
  \url{https://doc.rust-lang.org/nomicon/}
\end{thebibliography}
