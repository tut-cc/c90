\chapter{Rustへの道}
\begin{quotation}
  Program testing can be a very effective way to show the presence of bugs, \\
  but is hopelessly inadequate for showing their absence. ...

  The programmer should let correctness proof and program grow hand in hand.
\end{quotation}
\begin{flushright}
  --- Edsger W. Dijkstra,``The Humble Programmer'' (1972)
\end{flushright}

\section{前書き}
この種の同人誌に於ける利点は，何と言っても全く意識外の情報を仕入れる機会が得られる所だろう．
すると弊サークルのプログラミング言語大好きおじさんこと， @\_Nnwww が貴方に寄せる本記事の内容は1つしか無い，急進にして注目のプログラミング言語紹介である．
まぁ急進にして注目のといえば人の属する界隈によりけりだが，ここでは正式リリースから1年が経過し，
2016年にstack Overflowが行ったデベロッパー向けの調査にて「最も愛されている言語」に登りつめたプログラミング言語\cite{most_loved}，
「Rust」について紹介しよう．
即ち，本記事はRustについて，その言語が現れた文脈を共有しない読者の事も頭の幾らかに残しつつ，その理念や設計について示すものである．

なお，貴方がRustに今すぐ入門する意気に溢れているならばこの記事を読むよりも
rustup\cite{rustup}を導入し，
有志による翻訳リポジトリ\cite{rustdoc_ja}(拙訳も提供させていただいた)及びRustnomicon\cite{nomicon}の読破を推奨する．

間違い等については前述のアカウントに御一報下さい．文体ですか？やってみたかっただけです :)

\section{Rustとは}
Rustは「ゼロコスト抽象化」を実現する「トレイト」ベースの静的型付き「手続き型プログラミング」言語である．完！

というのは言葉足らずの私の主観だが事実しか並んでいない筈だ．
もう少し真面目に話せば1400人以上ものコントリビュータによって開発されているLLVMバックエンドのネイティブコンパイル言語であり，
Mozillaが製作中の新作webレンダリングエンジンServoの実装に用いられている．
公式では安全性，速度．並行性の3つの目標にフォーカスし，それらをガーベジコレクタ無しで実現するシステムプログラミング言語である，といった紹介がなされており，
レイヤ的にはこれまでC/C++のような言語が取り組んでいた領域に昨今の知見を持ち込む進捗だと言えるだろう．

さて，少なくともこの言語の場合，来たる知見の方角を意識しつつ機能を咀嚼するとわかりやすい．といっても大別して2つだと考えられる．
即ち「関数型プログラミングから来た知見」と「同レイヤの先達 （主にC++）にて醸成された知見」である．それでは見ていこう．

\section{ゼロコスト抽象化}
強力な抽象化，安全性検査等を実行時のコストを払わずに実現するという思想．
力の限り不適切に形容すると「あ〜HaskellがC言語並の実行速度で動かないかなぁ」という考えであり，プログラミングの理想主義である．
まさにRustの性格そのものであり，この理念に基づいて言語機能やライブラリが設計されている．
従ってコードを書く際のつらみも，書かれたコードのつよみも，大体この思想に依るものである．

\subsection{トレイト}
C++やJava，C\# に代表されるジェネリクスについて思い出して欲しい．
型をパラメータTに置き換える事により，逐一具体的な型についてコピーアンドペーストしなくとも
汎ゆる型を扱う事の出来る凄い奴だ．
だが，これらの言語のジェネリクスの型パラメータはそれがどういった性質の型であるか制約を課す事が出来ない．
そのため「ジェネリックな関数内のどの式でエラーが起きたか」は知ることが出来るが，
「その型にどういった性質が欠如していたのか」を具体的に知ることは出来ないのである．
\footnote{C++ではテンプレートメタプログラミングに依るConceptという手法で実現可能．
  \\ 言語機能としての実装が熱望されているが，C++11の頃から今日に至るまで延期され続けている...}

するとジェネリクスについて我々は考えを改めなければならない．
我々が必要なのは「汎ゆる型」ではなく，「特定の性質を持つ汎ゆる型」なのである．

トレイトとはこの語の和訳の通り，ある型が有する「特質」乃至は「特徴」を表す言語機能である．
此処で言う特質とは特定のシグネチャの関数群や関連する型が適切に実装されている事を指す．

せつめい〜

明らかに型クラスでは？と思った一部の諸兄，残念ながらHigherKindType対応では無いためFunctor等は努力が必要である．
RustはLLVMに依る最適化を受ける言語ではあるものの，モナ度の高まりはコンパイル時，実行時共にコストが蓄積しがちな代物であるし，
ゼロコスト抽象化と記述力向上を共に実現する言語機能として
健全なマクロとnightlyなコンパイラプラグインがあるため，諦めるのが賢明だろう．
これらの機能については入門してからのお楽しみである．

\subsection{所有権システム}
ゼロコスト抽象化を担う象徴的な機能のもう1つが所有権システムである．具体的には幾つかの概念，機能をまとめてこう記述されている．

\subsubsection{所有権そしてムーブセマンティクス}

\subsubsection{借用}
直接data raceの条件を書き下したかのような制約はRust発の特徴であると思われる．先達に心当たり有る方は是非御一報を．

\subsubsection{ライフタイム}
背景にはML KitやCycloneといった言語で実装されているRegionを用いた手法があるようだが残念ながら筆者の認識は概略程度であり元論文等は未読である．
より意欲的な読者は調べてみるのが良いだろう．


\section{現代の手続き型プログラミング}
Rustはマルチパラダイムのプログラミング言語だ．従って特定のプログラミングのスタイルを強くサポートする形態をとらない．
例えばRustはオブジェクト指向プログラミング言語\footnote{ここではメッセージング指
  向ではなくBjarne Stroustrup氏がC++に取り込みJava等でも用いられている「ユーザ定
  義型としてのオブジェクト指向」に仮定する}とは言えないだろう．
そもそもオブジェクトは無く，再現ができる機能は分割，分散されている．
\begin{itemize}
\item データ型単位ではなくモジュールがアクセスコントロールを行う
\item トレイトの「継承」
  \begin{itemize}
  \item この「継承」は実装しなければならないトレイトが増えるだけ
  \item OOPと異なり階層構造も出来ないし多態性も無い
  \end{itemize}
\item トレイトオブジェクトによる動的ディスパッチがオブジェクトの多態性に近い
  \begin{itemize}
  \item vtableと同様の仕組みを用いている
  \item 一段階のアップキャストとも言えるか
  \end{itemize}
\item メソッドチェーン記法は有る
  \begin{itemize}
  \item 中置演算子を自由に定義できないため，FPでも全体の流れはこれ頼み
  \end{itemize}
\end{itemize}
また，Rustは関数型プログラミング言語とも言えない．相性の悪いポイントは幾つも見当たる．
\begin{itemize}
\item 高階関数と相性が悪い標準のマクロtry!が有る
\item 標準ライブラリには副作用抑制より速度を取っている実装もある
  \begin{itemize}
  \item ミュータブルな参照による引数を介した書き戻しなど
  \end{itemize}
\item Rustは末尾再帰の最適化を保証しない
  \begin{itemize}
  \item LLVMに任せるのみ
  \end{itemize}
\item 中置演算子は自由に定義できない
  \begin{itemize}
  \item メソッドチェーン記法を使う
  \end{itemize}
\end{itemize}

有益であれば局所的にそういったモデルを構築するのは良い，
しかし常に模倣するのは得策と言えないだろう．

ではRustはどのようなプログラミング言語なのか？
私はRustを現代の手続き型プログラミング言語だと考えている．

\subsection{デフォルトイミュータブル}
今更話す事でも無いと思うが，コンテクスト云々と偉そうな事を放言してしまった為説明
する．
プログラムを書く際，全ての変数がデフォルトで不変であるという性質を指す．つまり，
通常の変数は変更する事が出来ず，特殊な修飾子を付けた変数のみ破壊的代入が可能にな
る．プログラムが複雑になる程，どの部分が書き換えられ得るのかを把握する事がバグを抑えこむ上で
重要となってくるが，デフォルトでミュータブルな変数の言語では不変である事を示す修
飾子が氾濫し可読性が低下するため，Rustではデフォルトイミュータブルが採用されてい
る．それでも速度にシビアな領域に取り組むこの言語では計算量優先でミュータブルな参照を用い
る事が多いが，前述の通り借用のルールによってミュータブルな変数は扱いが厳しいため，
入門直後は矢鱈にミュータブルな参照を用いるべきでは無いだろう．

\subsection{式指向}
多くの手続き型プログラミング言語ではif文が有名だろう．文は式の中に組み込む事が出
来ない．
以下はC言語での条件に応じた初期化である．

\begin{lstlisting}[language={C},caption=Cにおけるif文,label=c_if]
int cond = 5;

int res = 0;

if (cond == 5) {
    res = 10;
} else {
    res = 15;
}
\end{lstlisting}
式指向な言語，Rustでは以下のようになる．
\begin{lstlisting}[language={C++},caption=Rustにおけるif式,label=rust_if]
let cond = 5;
let res = if cond == 5 { 10 } else { 15 };
\end{lstlisting}
この些末なコードに意味はない．文にはスコープの隔たりがあり，余計な副作用の発生や，表現が途中で切断されるといった問題に注目して欲しい．

Rustではletによる変数宣言を除き単体での文は存在しない．基本的に式でプログラミングを構成していく事から公式はRustを「式指向」な言語と称している．
しかし文が使えない訳では無く，セミコロンを式に加えて返り値が無い\footnote{これは不正確である．詳細は入門してry}事を明示し，式を文にすることができる．ドキュメントでは．これを式文と表現している．
そのためお馴染み for のようなループも使用可能である．これ以上は詳細に立ち入って
しまうため，如何に整合性が保たれているかは実際に入門して確かめてみて欲しい．
何れにせよ，式指向は余計な副作用や処理のフローを切断せず，また情報量を柔軟に調整
でき，セミコロンの導入により文的にも扱えるため，従来の手続き的コードのほぼ上位互
換と言って差し支え無いだろう．
なお，この特徴的なセミコロンの使い方はSMLやOCamlからの影響であることが明言されている．\cite{inf}

\subsection{より疎結合なインターフェースとしてのトレイト}


\subsection{モジュールによる構造化とアクセスコントロール}
Rustはモジュールにプログラムの構造とアクセスコントロールを行う機能がある．
オブジェクト指向では各オブジェクトがアクセスコントロールの機能を有していたがRust
はその辺分業されており，また内部の実装に依存せず外部から見える構造を組み替える事
が出来るので良い．


\subsection{enum型とパターンマッチング}
代数的データ型，直和型，タグ付き共用体，他の言語では色々な呼ばれ方をしているが，Rustではそれをenumと呼んでいる．
これらは関数型プログラミングの知見が出自である．少なくともRustが影響を受けた出自はそうだ．
せつめい〜
enum型の強みはこの型を開く時，必ずバリアントの網羅性を要求することだ．
つまり，値を取り出そうとする際に，全てのバリアントの扱いを網羅できておらず，かつデフォルトのパターンも存在しない場合，コンパイルエラーとなるのである．
以上によって \textbf{nullの無い世界} が開かれる．値が無い可能性を有する型はenumに依って簡単に表現できるからだ．
\begin{lstlisting}[language={C++},caption=Option型,label=option_t]
enum Option<T> {
    None,
    Some(T),
}
\end{lstlisting}
エラーの際に情報を値として返したいならば，
\begin{lstlisting}[language={C++},caption=Result型,label=result_t]
enum Result<T, E> {
    Ok(T),
    Err(E),
}
\end{lstlisting}
が標準ライブラリで定義されている．\footnote{私個人としてはエラーに限らず「どちら
  かの値」を表すHaskellのEitherの方が優れた命名だと考えている．}

Quick Sort，Hoare論理，CSPの作者として知られるTony Hoare氏はnullを10億ドル相当の過ちと称した．
NullPointerExeptionの悪名たるやここで補足するまでも無いだろうが，
根本的原因は殆どの値に入り込む可能性があり，かつどの関数がnullを返すのか型に現れ
ないことにある．
だがnullを廃しenum型を導入すれば，高々数行の定義に依ってそういった問題を解決出来る．
少なくともRustにおいては，気付かぬ間に這いよるnullの影に怯える必要はまるで無いの
だ．

また，昨今の言語ではnull対策の為だけの言語機能も有るが，
enum型の表現力は非常に強く，それだけには留まらない．
再帰的に扱えば線形リストや，
\begin{lstlisting}[language={C++},caption=線形リスト,label=list_t]
enum List<T>{
    Nil,
    Cons(T, Box<List<T>>)
}
\end{lstlisting}
赤黒木等もこのように構造を意識した型付けが出来る，後はこの型を操作する関数を書い
ていけば良い．
\begin{lstlisting}[language={C++},caption=線形リスト,label=list_t]
enum RB{R, B}
enum RBTree<V>{
    Leaf,
    Node(RB, V, Box<RBTree<V>>, Box<RBTree<V>>)
}
\end{lstlisting}

型の直和と直積を使いこなす事で，
多くの構造に対して型を付け，
安全に無駄なく取り扱える事が実感できる
だろう．

\section{「例外」の無いエラーハンドリング}
さて本節ではRustのシステムプログラミングらしい側面について取り扱う．

\section{Rustの門を叩く}
rustは現在バージョン1.10.0
現在ライブラリの仕様がどんどんstableになっている最中
Rustは実践的な言語を目指しており，
安定化から1周年であるが非常に多くのドキュメントが書かれている．
従って今回は詳細な入門を書く事は避け，
如何なる要請に基づいて彼らがRustへ至ったのか，その道筋の一端を述べようと試みた．

貴方が門を叩き，理想のプログラミングを追求する一助と成れたならば幸いである．

\begin{thebibliography}{9}
\bibitem{most_loved} stackoverflow Developer Survey Results 2016 \\
  \url{https://stackoverflow.com/research/developer-survey-2016}
\bibitem{rustup} rustup: the Rust toolchain installer \\
  \url{https://github.com/rust-lang-nursery/rustup.rs}
\bibitem{rustdoc_ja} rust-lang-ja/the-rust-programming-language-ja \\
  \url{https://github.com/rust-lang-ja/the-rust-programming-language-ja}
\bibitem{nomicon} The Rustnomicon - The Dark Arts of Advanced and Unsafe Rust Programming \\
  \url{https://doc.rust-lang.org/nomicon/}
\bibitem{inf} The Rust Reference - Appendix: Influences \\
  \url{https://doc.rust-lang.org/reference.html#appendix-influences}
\end{thebibliography}
