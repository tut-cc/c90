\chapter{Rustへの道}

\section{前書き}
この種の同人誌に於ける利点は，何と言っても全く意識外の情報を仕入れる機会が得られる所だろう．
すると弊サークルのプログラミング言語大好きおじさんこと， \verb|@_Nnwww| が貴方に寄せる本記事の内容は1つしか無い，急進にして注目のプログラミング言語紹介である．
まぁ急進にして注目のといえば人の属する界隈によりけりだが，ここでは正式リリースから1年が経過し，
2016年にStack Overflowが行ったデベロッパー向けの調査にて「最も愛されている言語」に登りつめたプログラミング言語(https://stackoverflow.com/research/developer-survey-2016)，
「Rust」について紹介しよう．
即ち，本記事はRustについて，その言語が現れた文脈を共有しない読者の事も頭の幾らかに残しつつ，その理念や設計について示すものである．

なお，貴方がRustに今すぐ入門する意気に溢れているならばこの記事を読むよりも
rustup(https://github.com/rust-lang-nursery/rustup.rs)を導入し，
有志による翻訳リポジトリ(https://github.com/rust-lang-ja/the-rust-programming-language-ja)(拙訳も提供させていただいた)とRustnomicon(https://doc.rust-lang.org/nomicon/)の読破を推奨する．

間違い等については前述のアカウントに御一報下さい．文体ですか？やってみたかっただけです．

\section{Rustとは}
Rustは「ゼロコスト抽象化」を実現する「トレイト」ベースの静的型付き「手続き型プログラミング」言語である．完！

というのは言葉足らずの私の主観だが事実しか並んでいない筈だ．
もう少し真面目に話せば Mozilla によって現在開発されているLLVMバックエンドのネイティブコンパイル言語であり，
同社が製作中の新作webレンダリングエンジン Servo の実装に用いられている．
公式では安全性，速度．並行性の3つの目標にフォーカスし，それらをガーベジコレクタ無しで実現するシステムプログラミング言語である，といった紹介がなされており，
レイヤ的にはこれまでC/C++のような言語が取り組んでいた領域に昨今の知見を持ち込む進捗だと言えるだろう．

さて，少なくともこの言語の場合，来たる知見の方角を意識しつつ機能を咀嚼するとわかりやすい．といっても大別して2つだと考えられる．
即ち「関数型プログラミングから来た知見」と「同レイヤの先達(主にC++)にて醸成された知見」である．それでは見ていこう．

\section{ゼロコスト抽象化}
強力な抽象化，安全性検査等を実行時のコストを払わずに実現するという思想．
力の限り不適切に形容すると「あ〜HaskellがC言語並の実行速度で動かないかなぁ」という考えであり，プログラミングの理想主義である．
まさにRustの性格そのものであり，この理念に基づいて言語機能やライブラリが設計されている．
従ってコードを書く際のつらみも，書かれたコードのつよみも，大体この思想に依るものである．

\subsection{トレイト}
ゼロコスト抽象化を担う象徴的な機能の1つがトレイトである．
トレイトとはこの語の和訳の通り，ある型が有する「特徴」を示す言語機能だ，此処で言う特質とは特定のシグネチャの関数群や関連する型が実装されていることを指す．
例えばC++やJavaに代表されるジェネリクスでは型をパラメータTのようにして扱う事が出来るが，それがどういった性質の型であるか制約を課す事ができない．

我々に必要なのは「汎ゆる型を通すジェネリクス」ではなく

Rustは2つのジェネリクスを持つ．静的ディスパッチと動的ディスパッチである．
せつめい〜

明らかに型クラスでは？と思った一部の諸兄，残念ながらHigherKindType対応では無いためFunctor等は努力が必要である．
RustはLLVMに依る最適化を受ける言語ではあるものの，モナ度の高まりは明らかにオーバヘッドが積もっていく代物であるし，
構文糖としては健全なマクロとnightlyなコンパイラプラグイン(後述)があるため，諦めるのが賢明だろう．

\subsection{所有権システム}
ゼロコスト抽象化を担う象徴的な機能のもう1つが所有権システムである．具体的には幾つかの概念，機能をまとめてこう記述されている．

\subsubsection{所有権そしてムーブセマンティクス}

\subsubsection{借用}
直接data raceの条件を書き下したかのような制約はRust発の特徴であると思われる．先達に心当たり有る方は是非御一報を．

\subsubsection{ライフタイム}
背景にはML KitやCycloneといった言語で実装されているRegionを用いた手法があるようだが残念ながら筆者の認識は概略程度であり元論文等は未読である．
より意欲的な読者は調べてみるのが良いだろう．


\section{現代の手続き型プログラミング}
Rustはオブジェクト指向プログラミング言語ではない．そもそもオブジェクトといった強力過ぎる機能(メッセージング指向ではなくBjarne Stroustrup氏辺りが提唱したユーザ定義型としてのオブジェクト指向に仮定するが)は無く，機能が分割，分散されている．
\begin{itemize}
\item 構造体では無くモジュール単位でアクセスコントロールを行う
\item トレイトの「継承」による差分プログラミング
  \begin{itemize}
  \item この「継承」は実装の対象が増えるだけ
  \item OOPと異なり多態性を持たない事に注意
  \end{itemize}
\item トレイトオブジェクトによる動的ディスパッチがオブジェクトの多態性に近い
  \begin{itemize}
  \item vtableと同様の仕組みを用いている
  \end{itemize}
\end{itemize}
また，Rustは関数型プログラミング言語でもない．相性の悪いポイントは幾つも見当たる．
\begin{itemize}
\item 高階関数と相性が悪い標準のマクロtry!が有る
\item 標準ライブラリは副作用抑制よりも速度を取る
  \begin{itemize}
  \item mut参照による引数を介した書き戻しなど
  \end{itemize}
\item Rustは末尾再帰の最適化を保証しない
  \begin{itemize}
  \item LLVMに任せるのみ
  \end{itemize}
\end{itemize}

(当然ながら不可能な訳ではない．局所的にそういったスタイルの再現や模倣は可能)

ではRustとは何か？
Rustは改善された現代の手続き型プログラミング言語である．

\subsection{補足: 副作用}

\subsection{デフォルトイミュータブル}

\subsection{式指向}
多くの手続き型プログラミング言語ではif文が有名だろう．
以下はC言語での条件に応じた初期化である．

\begin{lstlisting}[language={C},caption=Cにおけるif文,label=c_if]
int cond = 5;

int res = 0;

if (cond == 5) {
    res = 10;
} else {
    res = 15;
}
\end{lstlisting}
式指向な言語，Rustでは以下のようになる．
\begin{lstlisting}[language={C++},caption=Rustにおけるif式,label=rust_if]
let cond = 5;
let res = if cond == 5 { 10 } else { 15 };
\end{lstlisting}
この些末なコードに意味はない．文にはスコープの隔たりがあり，余計な副作用の発生や，表現が途中で切断されるといった問題に注目して欲しい．

Rustではletによる変数宣言を除き単体での文は存在しない．基本的に式でプログラミングを構成していく事から公式はRustを「式指向」な言語と称している．
しかし文が使えない訳では無く，セミコロンを式に加えて返り値が無い(これは不正確である．詳細は入門してry)事を明示し，式を文にすることができる．ドキュメントでは．これを式文と表現している．
お馴染み `for` のようなループも使用可能である．これ以上は詳細に立ち入ってしまうため，どのように整合性を保たれているかは実際に入門して確かめてみて欲しい．
なお，この特徴的なセミコロンの使い方はSMLやOCamlからの影響であることが明言されている．

\subsection{より疎結合なインターフェースとしてのトレイト}


\subsection{モジュールによる構造化とアクセスコントロール}


\subsection{enum型とパターンマッチング}
代数的データ型，直和型，タグ付き共用体，他の言語では色々な呼ばれ方をしているが，Rustではそれをenumと呼んでいる．
これらは関数型プログラミングの知見が出自である．少なくともRustが影響を受けた出自はそうだ．
せつめい〜
enum型の強みはこの型を開く時，必ずバリアントの網羅性を要求することだ．
つまり，値を取り出そうとする際に，全てのバリアントの扱いを網羅できておらず，かつデフォルトのパターンも存在しない場合，コンパイルエラーとなるのである．
以上によって \textbf{nullの無い世界} が開かれる．値が無い可能性を有する型はenumに依って簡単に表現できるからだ．
\begin{lstlisting}[language={C++},caption=Option型,label=option_t]
enum Option<T> {
    None,
    Some(T),
}
\end{lstlisting}
エラーの際に情報を値として返したいならば，
\begin{lstlisting}[language={C++},caption=Result型,label=result_t]
enum Result<T, E> {
    Ok(T),
    Err(E),
}
\end{lstlisting}
が標準ライブラリで定義されている．(私個人としてはエラーに限らず「どちらかの値」を表すHaskellのEitherの方が優れた命名だと考えている)

Quick Sort，Hoare論理，CSPの作者として知られるTony Hoare氏はnullを10億ドル相当の過ちと称した．
我々はこの型の直和を持って，古い時代から脱出すべきなのだ．(といっても関数型プログラミングでは随分昔から用いられていたのだが)

\section{「例外」の無いエラーハンドリング}
さて本節ではRustのシステムプログラミングらしい側面について取り扱う．

\section{Rustの門を叩く}
rustは現在バージョン1.10.0
現在ライブラリの仕様がどんどんstableになっている最中
